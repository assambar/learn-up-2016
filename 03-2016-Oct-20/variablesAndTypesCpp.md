# Типизация на данните/изразите в C++. Типова система. Променливи.

-   C++ притежава относително богат набор от примитивни, или още наричани
    фундаментални, типове данни, а от друга страна предоставя и възможността да
    бъдат дефинирани и използвани произволни агрегатни (съставни) типове,
    съответстващи по-добре на целите на програмиста и абстрактните или конкретни
    идеи, които той желае максимално директно да изрази в изходния код, в лицето
    на класове/структури и обединения, както и изброяващи типове (enumerations,
    enums, C++11 също разполага и с enum classes или още scoped enums).

## Какво е това тип, какво е типова система, и защо е необходима?

-   типовете са един вид етикети, носени от не само всяка една променлива (в
    това число и инстанции на класове), но изобщо всеки израз.
-   типът диктува как трябва, или как може, да бъде изтълкувана всяка една
    стойност, в най-общия смисъл на думата, както и какви операции са
    валидни/дефинирани за всяка една стойност или съответно две и повече
    стойности.
-   чисто технически, типът придава значение на поредицата от байтове, или
    машинни думи (някой път дори единични битове (виж vector<bool>)).
-   по общо, в програмните езици (или поне в по-добрите такива) типовата
    система придава семантични тълкование и стойност на всеки аспект от една
    програма/софтуерна система (това **не** важи напълно по отношение на C++, но
    пък вижте Haskell, SML, OCaml, Clean, Scheme&#x2026;).

## Особености на типовете в C++.

-   C++ е изграден върху основата, предоставена от C, и е почти напълно обратно
    съвместим с последния. от C, езикът, върху който пада напето внимание,
    наследява типизацията на данните и поне по отношение на примитивните типове
    не внася никакви (съществени) изменения, затова нека да кажем две думи за
    C, и защо типовете там са това, което са.
    -   C е създаден през периода 1969-1973, по време, когато всякакъв системен
        софтуер неизменно е бил писан на асемблерен език (Assembly). в процеса
        разработката на Unix и Multics преди това се вижда, че нито асемблерът,
        нито пък езици като FORTRAN, PL/1 и CPL представляват адекватни решения в
        търсенето на modularity, composability, reusability и тъй нататък
        свойства на една добре изградена софтуерна система. необходим е бил език,
        който да предоставя a more or less one-to-one mapping to the underlying
        hardware peculiarities, yet is as portable as possible between different
        hardware architectures, operating systems, etc. за целта е било
        необходимо начина, по който програмиста на C да борави с данни по същия
        начин както ги вижда процесора, с цел максимална ефикасност и максимална
        портабилност. резултатът е, че всеки тип данни притежава конкретно и
        директно представяне в адресното пространство на процеса - да речем един
        char задължително се побира в точно един байт, който от своя страна
        обикновено е фундаменталната (и най-малка) адресируема единица (entity)
        от гледната точка на процесора (байтовете често, но не винаги, са октети
        от битове).
    -   всичко това е така и в C++, преди да намесим класовете, особено в
        контекста на виртуален полиморфизъм и други технологически аспекти от
        обектната система на езика.

## Най-важните типове.

-   **bool:** типът на Булевата алгебра, поддържан от езика, приемащ една
    измежду две стойности - true и false. всъщност приема произволни
    относително малки целочислени стойности, като 0 се тълкува като
    false, а всичко останало - като true. следващата функция има за
    стойност истинността на твърдението a > b, за някакви a, b,
    представители на тип, за който е дефинирано (числово) сравняване.
    
        template<typename Numeric>
        bool isGreater(Numeric a, Numeric b)
        {
          return a > b;
        }
-   **char:** символ, да речем 'a', но не 'λ' или '好'. защо? ето защо -
    променливи и изобщо изрази от тип char са всъщност доста малки
    целочислени стойности отговарящи на символите в някой фиксиран
    character set, най-често ASCII. ASCII е седем-битов char set,
    тоест, стойностите, кореспондиращи на символите в ASCII варират м/у
    0 и 127 = 2<sup>7</sup> -1. а пък char винаги се помещава върху <span class="underline">един</span> байт
    (обикновено осем бита, или 2<sup>8</sup> = 256 възможни стойности). това ни
    отвежда към следващия тип.
-   **char const \*const:** това е константен указател към константен char, или
    константен (неизменим) символен низ, да речем "Hello there, nice to meet
    you". по-нататък ще се убедим, че std::string е съществено по-добър
    вариант.
-   **int:** цели числа, обикновено представени върху 32 бита (пресметнете към
    кой затворен под-интервал на ℤ принадлежат всички стойности, които
    приема int!).
-   **double:** числа с плаваща запетая, с двойна прецизност, приближение към
    математическата концепция за реално число.

## Променливи.

-   **обекти** се наричат малки региони памет в адресното пространство на
    програмата (и съответно в контекста виртуалната памет на операционната
    система), който съдържа конкретна стойност от определен тип. тук говорим за
    обекти в най-обшия и най-фундаменталния (или пък най-примитивния) смисъл на
    думата, а не обекти като инстанции на класове.
-   **стойност** е <del>набор</del> последователност от битове, или перманентно
    присъстващи в паметта на програмата, или само временно в контекста
    оценяването на някой съставен израз (да речем, временно налична ще бъде
    целочислената стойност 5 в контекста оценяването на следния израз:
    12.8067 \* (2 + 3)). тази последователност от битове бива оценена съгласно
    определения тип.
-   **променлива** е всеки обект от гореспоменатия вид, на който е дадено име в
    програмния текст. да речем, в следния откъс cute е една такава променлива.

        #include <cstdlib>
        #include <iostream>

        int main(void)
        {
          int cute {23};
          std::cout << "The value of a variable, named \"cute\" is " << cute << "\n";

          return EXIT_SUCCESS;
        }